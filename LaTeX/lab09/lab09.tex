\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
%\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage{ulem} 

\usepackage[T2A]{fontenc} % и без этого работает?
\usepackage[utf8x]{inputenc}
\usepackage[russian]{babel}
\usepackage{cmap} % для работы поиска кириллицы в pdf
% \renewcommand{\rmdefault}{Eksal}
% \renewcommand{\rmfamily}{Eksal}


\lstset{language=C++,
	basicstyle=\footnotesize\sffamily,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=false % переносить строки только если есть пробел
}
\parindent=1cm
\makeatletter

\newcommand{\print}[1]{{\large  \bf  #1} 
{\scriptsize \lstinputlisting[language=C++]{../../lab09/#1}}}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\linespread{1}
% \usepackage{fontspec}
%\pgfplotsset{compat=1.16}
% \usepackage{amsfonts,fontinst}
% \documentclass[a4paper]{article}
% \usepackage{fontspec}
% \setmainfont{Eksal}     % задаёт \rmfamily, основной шрифт документа
% \setmainfont{Eksal}
% \setsansfont{Verdana}
% bickham}
% \installfont{}

\begin{document}

\section*{\centering Лабораторная работа №\,8 по курсу:\\ Дискретный анализ}

Выполнил студент группы М8О-208Б-17 МАИ \,\, \textit{Милько Павел}.

\subsection*{Задача}

\paragraph*{Вариант 8}: Поиск максимального паросочетания алгоритмом Куна\\
Задан неориентированный двудольный граф, состоящий из $n$ вершин и $m$ ребер.
Вершины пронумерованы целыми числами от $1$ до $n$. 
Необходимо найти максимальное паросочетание в графе алгоритмом Куна.
Для обеспечения однозначности ответа списки смежности графа следует предварительно отсортировать. Граф не содержит петель и кратных ребер.

\textit{ \textbf{Входные данные}}: 
В первой строке заданы $1 \le n \le 110000$ и $1 \le m \le 40000$. В следующих m
строках записаны ребра. Каждая строка содержит пару чисел --- номера
вершин, соединенных ребром.


\textit{ \textbf{Выходные данные}}: 
В первой строке следует вывести число ребер в найденном
паросочетании. В следующих строках нужно вывести сами ребра, по
одному в строке. Каждое ребро представляется парой чисел --- номерами
соответствующих вершин. Строки должны быть отсортированы по
минимальному номеру вершины на ребре. Пары чисел в одной строке
также должны быть отсортированы.

\subsection*{Информация}

С помощью алгоритма Куна решается т.н. задача о назначениях, когда для каждого работника нужно предоставить задание, чтобы как можно большее число работников были заняты. Собственно задача сводится к нахождению самого длинного паросочетания.

\textbf{Паросочетание} --- набор попарно несмежных рёбер графа (никакие 2 ребра не имеют общую вершину).

\textbf{Цепь} --- простой путь в графе (список вершин), где соседние вершины соединены рёбрами.

\textbf{Чередующаяся цепь} --- цепь, в которой рёбра поочерёдно принадлежат/не принадлежат некоторому паросочетанию.

\textbf{Увеличивающая цепь} --- чередующаяся цепь, в которой начальное и конечное ребро не принадлежат паросочетанию.

\textbf{Теорема}(Бержа):\\Паросочетание является максимальным тогда и только тогда, когда относительно него не существует увеличивающих цепей.

\subsection*{Метод решения}

Алгоритм Куна непосредственно использует теорему Бержа: сначала берётся пустое паросочетание и ищется увеличивающая относительно него цепь. Вдоль этой цепи будет происходить чередование паросочетания, и уже относительно нового паросочетания будет происходит поиск увеличивающей цепи. Если цепь найти не удалось --- текущее паросочетание максимальное.

Искать увеличивающие цепи можно с помощью алгоритмов поиска в глубину или поиска в ширину. Ради простоты реализации я выбрал первый алгоритм.

Для записи текущего паросочетания использован массив $mt$, в котором элемент $mt[i] = j,j \ne -1$ означает, что вершина $i$ насыщена паросочетанием, и есть путь $i \rightarrow j$, если $j = -1$, то вершина $i$ не насыщена паросочетанием.

Так как доли графа явно не заданы, то при насыщении какой-либо вершины нужно зеркально продублировать запись для второй доли графа.

\textit{ \textbf{Оценочная сложность алгоритма}}: по сути происходит $n$ вызовов обхода графа, соответственно, итоговая сложность составляет $O(n*m)$ или $O(n^3)$  
\subsection*{Исходный код}

\print{main.cpp}

% \subsection*{Генератор тестов}

% \lstinputlisting[language=Python]{../../lab08/gen.py}
\subsection*{Выводы}

Алгоритм Куна довольно простой, в основном из за того что я использую dfs для поиска увеличивающих цепей. Однако я смог сделать его неправильно, т.к. забыл про вторую долю графа (надо было зеркально продублировать данные для второй доли). Алгоритмы на графах всегда вводили меня в уныние, так как в большинстве из них довольно затруднительно понять что вообще происходит, я ожидал намного больше боли и унижений, но рандомайзер меня порадовал Куном, а не Беллманом-Фордом.

\end{document}

