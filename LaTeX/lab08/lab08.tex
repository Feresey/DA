\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
%\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage{ulem} 
% \usepackage{lmodern}
% \usepackage{textcomp}

\lstset{language=C++,
	basicstyle=\footnotesize\sffamily,
	showspaces=false,
	showstringspaces=false,
	showtabs=false,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=false % переносить строки только если есть пробел
}
\parindent=1cm
\makeatletter

\newcommand{\print}[1]{{\large \textbf{#1}} 
{\scriptsize \lstinputlisting[]{../../lab08/#1}}}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\linespread{1}
%\pgfplotsset{compat=1.16}
\begin{document}

\section*{\centering Лабораторная работа №\,8 по курсу:\\ Дискретный анализ}

Выполнил студент группы М8О-208Б-17 МАИ \,\, \textit{Милько Павел}.

\subsection*{Задача}

Разработать жадный алгоритм решения задачи, определяемой своим
вариантом. Доказать его корректность, оценить скорость и объём
затрачиваемой оперативной памяти.
Реализовать программу на языке C или C++, соответствующую
построенному алгоритму. Формат входных и выходных данных описан в
варианте задания.


\paragraph*{Вариант 6:} Топологический поиск.\\
Заданы $N$ объектов с ограничениями на расположение вида ``$A$ должен
находиться перед $B$''. Необходимо найти такой порядок расположения
объектов, что все ограничения будут выполняться.

\textit{\textbf{Входные данные:}} на первой строке два числа, $N$ и $M$, за которыми следует M строк с
ограничениями вида ``$A$ $B$'' $(1 \le A, B \le N )$ определяющими
относительную последовательность объектов с номерами $A$ и $B$.

\textit{ \textbf{Выходные данные:}}  $−1$ если расположить объекты в соответствии с
требованиями невозможно, последовательность номеров объектов в
противном случае.

\subsection*{Информация}

Суть жадных алгоритмов состоит в принятии локально-оптимальных решений в надежде, что
конечное решение так же окажется оптимальным. Но не всегда применим жадный алгоритм, чтобы
доказать корректность его применения, нужно доказать что исследуемый объект является
матроидом.

Матроидом называется пара множеств $E$, $I$, состоящая из конечного множества $E$, называемого
базовым множеством матроида, и множества его подмножеств $I$, называемого множеством
независимых множеств матроида, причем $I$ удовлетворяет свойствам:
\begin{itemize}
	\item Множество $I$ не пусто. Даже если исходное множество $E$ было пусто -- $E = 0$, то $I$ будет состоять из одного элемента - множества, содержащего пустое $I = \{\{0\}\}$.
	\item Любое подмножество любого элемента множества $I$ также будет элементом этого
	      множества.
	\item Если $X, Y \in I$, причем $|X| = |Y| + 1$, тогда существует элемент
	      $x \in X\backslash Y$, такой что $Y \cup \{x\} \in I$.
\end{itemize}

\noindent Этапы построения алгоритма решения подзадач:
\begin{itemize}
	\item Описать структуру оптимального решения.
	\item Составить рекурсивное решение для нахождения оптимального решения.
	\item Вычисление значения, соответствующего оптимальному решению, методом
	      восходящего анализа.
	\item Непосредственное нахождение оптимального решения из полученной на предыдущих
	      этапах информации.
\end{itemize}

\subsection*{Метод решения}

Для решения моей задачи использовался немного упрощенный (казалось бы куда ещё проще) dfs для поиска циклов в графе. Оригинальный алгоритм раскрашивал вершины в три цвета, в моей же задаче циклов нет по условию, мне лишь нужно не заходить в уже посещённые вершины. Сам обход тривиален и жаден до невозможности.

\textbf{ \textit{Оценочная сложность:}} по сути вызывается обход в глубину для каждой компоненты связности графа. Есть 2 крайних случая: когда все вершины принадлежат разным компонентам связности (граф без рёбер), и случай когда компонента связности всего одна, зато путей в графе максимально возможное количество.

В первом случае сложность будет $O(n)$. Во втором --- $O(m)$ или $O(n^2)$ в худшем случае. Итого асимптотика алгоритма такая же как у dfs.
\subsection*{Исходный код}


\print{main.cpp}

\subsection*{Генератор тестов}

\lstinputlisting[language=Python]{../../lab08/gen.py}
\subsection*{Выводы}

Чем жаднее тем проще! Жадные алгоритмы мне понравились больше чем динамическое программирование, хотя теория и кажется намного сложнее, она интуитивно понятна и её довольно просто применять на практике. Они встречаются сплошь и рядом. Те же алгоритмы обхода в глубину и в ширину. Наверное все алгоритмы на графах (и на деревьях, как частных случаях графов, соответственно) являются жадными. Тут простор для примеров открывается огромный: от Укконена до Хаффмана.

Хотя отчасти жадные алгоритмы являются частным случаем динамического программирования. Не так сложно сделать жадный алгоритм, как доказать что его можно использовать.

\end{document}

