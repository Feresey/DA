\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}

\parindent=1cm
\makeatletter
\newcommand{\rindex}[2][\imki@jobname]{%
	\index[#1]{\detokenize{#2}}%
}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\hfuzz=10000pt
\vbadness10000
\linespread{1}
%\linespread{1.1}
% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискрeтного\\ анализа: сортировка за линейное время}

Выполнил студент группы 08-208 МАИ \textit{Милько Павел}.
\subsection*{Условие}

Требуется разработать программу, осуществляющую ввод пар ``ключ-значение'' и их сортировку за линейное время: 
\begin{enumerate}
\item На каждой непустой строке входного файла располагается пара ``ключ-значение'', разделённые знаком табуляции. В выходных данных должны быть отсортированные строки исходной последовательности (за исключением пустых)
\item Вариант задания: 4-1
\begin{itemize}

 \item[\textbf{ \it Ключи---}] Даты в формате DD.MM.YYYY, например:\\ 1.1.1, 1.9.2009, 01.09.2009, 31.12.2009.
 \item[\textbf{ \it Значения---}] Строки фиксированной длины 64 символа, во входных данных могут встретиться строки меньшей длины, при этом строка дополняется до 64-х нулевыми символами, которые не выводятся на экран.

\end{itemize}
\end{enumerate}

\subsection*{Метод решения}
	\begin{enumerate}
	
	\item  Данные на вход программе подаются через перенаправление вывода из файла, и, как следствие, весьма удобно считывать циклом while(особенно это важно при неизвестном количестве строк).\\ Когда будет считан символ EOF, цикл завершится.
	
	
	\item Предусмотрена работа программы с неизвестным количеством входных данных.

	
	\item По алгоритму сортировки необходим дополнительный массив ключей, размером равным количеству пар ``ключ-значение'', для переключения между двумя буферами (исходным и вспомогательным) используется дополнительный массив с ссылками на оба буфера. 
		
	\item Сортировку происходит по нескольким полям значений, для более лаконичного вида был использован цикл ``foreach''\\
	сортировка для каждого разряда числа производится так же в функции 	``main''
	
	\item Собственно сам алгоритм сортировки принимает на вход ссылки на входной и выходной буфер, а так же переменную, описывающую текущий сортирующийся разряд. Так же содержит в себе цикл ``while'' с условием, что каждая строка ``нашла своё место'' в выходном буфере
\end{enumerate}
%Общее описание алгоритма решения задачи, архитектуры программы и т.\,п. Полностью расписывать алгоритмы необязательно, но в общих чертах описать нужно. Приветствуются ссылки на внешние источники, использованные при подготовке (книги, интернет-ресурсы). 


\subsection*{Описание программы}

\begin{itemize}
	\item \textbf{main.cpp}\\ 
	Основной файл, содержит в себе собственно функцию ``main'' и функцию сортировки ``RadixSort''
	\item \textbf{struct.cpp}\\
	По сути является дополнением к структуре, описанной в заголовочном файле. Содержит только функцию парсинга строки-ключа и запись полученных данных в структуру
	\item \textbf{struct.hpp}\\
	Содержит в себе все используемые константы, структуру ключа, прототип функции парсинга и целиком функцию перевыделения памяти (создание массива увеличенного  размера и перезапись в него данных исходного)
\end{itemize}
%Разделение по файлам, описание основных типов данных и функций. 

\subsection*{Дневник отладки}
При создании следующей таблицы была использована история локального гит-репозитория.
\smallbreak
\noindent
\begin{tabular}{|l|p{2.7cm}|P{0.675\linewidth}|}
	\hline
	Время& Коммит& Описание	\\ \hline
	11 21:22:25&init &Начало работы, есть только шаблоны файлов и функций\\	\hline
	11 22:05:16& parsing& Заготовки под функцию парсинга, поиск необходимых методов и тестирование функции + 3 таких же коммита\\ 	\hline
	11 22:16:57&оптимизация указателей& Изменение структуры ключа, замена строки ссылкой на элемент отдельного массива строк\\ \hline
	12 13:31:19&убрал утечки памяти&Не освобождалась вся память, в самой структуре ключа я выделил память для указателя на строку, потом это значение перезаписывалось с ввода, а выделенная ранее память не освобождалась\\ \hline
	12 13:55:02&доделать сортировку &Была проблема с логикой алгоритма сортировки, цикл завершался досрочно, либо значения не отсортировывались в нужном порядке + 3 коммита мелкие исправления\\ \hline
	15 21:33:11&cut last symbol&Заметил, что обрезается последний символ строки-значения + 18 коммитов на то, чтобы понять, что необходимо создать механизм динамического расширения выделенной памяти\\ \hline
	19 14:36:07&WORKING!!!!&Рабочая версия программы, чекер отправил ОК, далее проходила незначительная оптимизация кода и контроль кодстайла\\ \hline
	22 11:39:58& string->char*& Узнал что такое стандартные контейнеры STL в С++, пришлось переводить все вхождения на массив char-ов\\ \hline
	22 21:47:39&Conditional jump or move & Надо было учесть, что строки обязаны заканчиваться символом $\backslash 0$, для корректной обработки строк \\ \hline
	
\end{tabular}
\smallbreak


Так же при проверке работы программы учитывалось время её исполнения (утилита time), осуществлялся контроль различных ошибок и утечек памяти (утилита valgrind) и отдельно для тестов применялась утилита memusage.
%Что и когда делали, что не работало, как чинили. Этот пункт обязательный, если было сделано несколько посылок. Кратко опишите суть проблемы и способ ее устранения.

\subsection*{Тест производительности}
Тесты создавались с помощью небольшой программы на языке Python:
\begin{lstlisting}[language=python]
def tests():
    from random import randint as ri
    from os import urandom as ur
    res=[]
    for count in range(1,10):
        f=open(str(count)+'00k','w')
        for i in range(100000):
            res.append(str(ri(0,30))+'.'+\
            str(ri(0,12))+'.'+\
            str(ri(0,2020))+'\t'+\
            ur(ri(0,32)).hex())
        for i in res:
            f.write(i+'\n')
        f.close()

\end{lstlisting}
\begin{table}
	\centering

\begin{tabular}{|c |m{5cm}|}
	\hline
	Размер файла& Имя файла и количество тысяч строк в нём\\ \hline
	4,1M&	100k\\
	
	8,1M&	200k\\
	
	13M	&	300k\\
	
	17M	&	400k\\
	
	21M	&	500k\\
	
	25M	&	600k\\
	
	29M &	700k\\
	
	33M	&	800k\\
	
	37M	&	900k\\ \hline
\end{tabular}
\end{table}

\begin{tikzpicture}
	\begin{axis}[ylabel=Время,xlabel=Количество строк, width=15.5cm, height=10cm,grid=both]
	\addplot coordinates {
		( 1000, 0.837 )
		( 900, 0.743 )
		( 800, 0.65  )
		( 700, 0.567 )
		( 600, 0.48  )
		( 500, 0.405 )
		( 400, 0.322 )
		( 300, 0.243 )
		( 200, 0.163 )
		( 100, 0.085  )};
	\addplot coordinates {
	( 110, 0.085)
	( 1010, 0.837 )};
	\end{axis}

\end{tikzpicture}

Итого, по графику результатов времени выполнения программы, её сложность близка к линейной.
\\

\begin{tikzpicture}
\begin{axis}[ylabel=Количество строк,xlabel=Байты, width=15.5cm, height=10cm,grid=both]
\addplot coordinates {
	( 18303830 ,  100  ) 
	( 36403806,  200  )
	( 56903782,  300  )
	( 79803758,  400  )
	( 105103734, 500  )
	( 132803710, 600  )
	( 162903686, 700  )
	( 195403662, 800  )
	( 230303638, 900  )
	( 267603614, 1000 )};
\end{axis}
\end{tikzpicture}

Небольшой изгиб графика обусловлен тем, что при заполнении выделенной памяти выделяется дополнительная память для $100\ 000$ значений, а не для одного, что более логично, но менее эффективно. При числах, на порядок больших чем размер изначально выделяемой памяти, зависимость размера выделяемой памяти приближается к линейной.


%Померить время работы кода лабораторной и теста производительности на разных объемах входных данных. Сравнить результаты. Проверить, что рост времени работы при увеличении объема входных данных согласуется с заявленной сложностью.


\subsection*{Недочёты}

%\smallbreak
В ходе проверки работы на чекере выяснилось, что весьма важной характеристикой работы программы является время вывода данных в консоль (например для 400 000 входных строк только вывод конечного результата работы программы занимал 2.3 секунды, при времени сортировки около 0.7 секунд). Было найдено несколько сомнительных решений на просторах интернета, но в коде программы остался printf, т.\,к. он выводит те же 400 000 строк на 0.2 секунды быстрее, чем std::cout.

%Описать те проблемы, которые остались нерешёнными в программе. Если
%выявленных недочётов нет, то этот пункт можно пропустить. Если же
%задача была принята с оговорками (медленно работает, неверно выполняет
%какие-то тесты), то нужно обязательно их упомянуть, привести возможные
%причины, указать почему не получилось исправить недочёты. 
%\newpage
\subsection*{Выводы}


Данную программу можно применять для сортировки важных исторических событий, для их последующей обработки и добавления, например, в учебник.\\

Также существует вариант создания базы данных военкомата, в которой в роли строки-значения будет выступать адрес проживания призывника, а в качестве ключа будет использоваться дата рождения. Такая база, отсортированная по дате рождения обеспечивает более лёгкий анализ данных о призывниках текущего года.\\


Написание программы было сложным из за отсутствия навыков работы с языком С++, большая часть времени была потрачена на поиск оптимального, кратчайшего и эффективного способа выполнения функций.


Проблемы возникали при работе с указателями на динамические массивы, часто встречались логические ошибки при выделении, освобождении и перезаписи ячеек памяти.


В целом написание даной лабораторной послужило поводом к изучению особенностей языка С++ и их применению в реальных проектах.


%Описать область применения реализованного алгоритма. Указать типовые
%задачи, решаемые им. Оценить сложность программирования, кратко
%описать возникшие проблемы при решении задачи. 

\end{document}

