\documentclass[12pt]{article}
\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{pgfplots}

\newcolumntype{P}[1]{>{\arraybackslash}p{#1}}
%\linespread{1.1}
% Оригиналный шаблон: http://k806.ru/dalabs/da-report-template-2012.tex

\begin{document}

\section*{Лабораторная работа №\,1 по курсу дискрeтного\\ анализа: сортировка за линейное время}

Выполнил студент группы 08-208 МАИ \textit{Милько Павел}.
\subsection*{Условие}

Требуется разработать программу, осуществляющую ввод пар ``ключ-значение'' и их сортировку за линейное время: 
\begin{enumerate}
\item На каждой непустой строке входного файла располагается пара ``ключ-значение'', разделённые знаком табуляции. В выходных данных должны быть отсортированные строки исходной последовательности (за исключением пустых)
\item Вариант задания: 4-1
\begin{itemize}

 \item[\textbf{ \it Ключи---}] Даты в формате DD.MM.YYYY, например:\\ 1.1.1, 1.9.2009, 01.09.2009, 31.12.2009.
 \item[\textbf{ \it Значения---}] Строки фиксированной длины 64 символа, во входных данных могут встретиться строки меньшей длины, при этом строка дополняется до 64-х нулевыми символами, которые не выводятся на экран.

\end{itemize}
\end{enumerate}

\subsection*{Метод решения}
	\begin{enumerate}
	
	\item  Данные на вход программе подаются через перенаправление вывода из файла, и, как следствие, весьма удобно считывать циклом while(особенно это важно при неизвестном количестве строк).\\ Когда будет считан символ EOF, цикл завершится.
	
	
	\item Предусмотрена работа программы с неизвестным количеством входных данных.

	
	\item По алгоритму сортировки необходим дополнительный массив ключей, размером равным количеству пар ``ключ-значение'', для переключения между двумя буферами (исходным и вспомогательным) используется дополнительный массив с ссылками на оба буфера. 
		
	\item Сортировку происходит по нескольким полям значений, для более лаконичного вида был использован цикл ``foreach''\\
	сортировка для каждого разряда числа производится так же в функции 	``main''
	
	\item Собственно сам алгоритм сортировки принимает на вход ссылки на входной и выходной буфер, а так же переменную, описывающую текущий сортирующийся разряд. Так же содержит в себе цикл ``while'' с условием, что каждая строка ``нашла своё место'' в выходном буфере
\end{enumerate}
%Общее описание алгоритма решения задачи, архитектуры программы и т.\,п. Полностью расписывать алгоритмы необязательно, но в общих чертах описать нужно. Приветствуются ссылки на внешние источники, использованные при подготовке (книги, интернет-ресурсы). 


\subsection*{Описание программы}

\begin{itemize}
	\item \textbf{main.cpp}\\ 
	Основной файл, содержит в себе собственно функцию ``main'' и функцию сортировки ``RadixSort''
	\item \textbf{struct.cpp}\\
	По сути является дополнением к структуре, описанной в заголовочном файле. Содержит только функцию парсинга строки-ключа и запись полученных данных в структуру
	\item \textbf{struct.hpp}\\
	Содержит в себе все используемые константы, структуру ключа, прототип функции парсинга и целиком функцию перевыделения памяти (создание массива увеличенного  размера и перезапись в него данных исходного)
\end{itemize}
%Разделение по файлам, описание основных типов данных и функций. 

\subsection*{Дневник отладки}
При создании следующей таблицы была использована история локального гит-репозитория, по коммитам примерно восстановлен порядок действий и описание возникших ошибок.
\smallbreak
\noindent
\begin{tabular}{|l|p{2.7cm}|P{0.675\linewidth}|}
	\hline
	Время& Коммит& Описание	\\ \hline
	11 21:22:25&init &Начало работы, есть только шаблоны файлов и функций\\	\hline
	11 22:05:16& parsing& Заготовки под функцию парсинга, поиск необходимых методов и тестирование функции + 3 таких же коммита\\ 	\hline
	11 22:16:57&оптимизация указателей& Изменение структуры ключа, замена строки ссылкой на элемент отдельного массива строк\\ \hline
	12 13:31:19&убрал утечки памяти&Не освобождалась вся память, в самой структуре ключа я выделил память для указателя на строку, потом это значение перезаписывалось с ввода, а выделенная ранее память не освобождалась\\ \hline
	12 13:55:02&надо будет доделать сортировку &Была проблема с логикой алгоритма сортировки, цикл завершался досрочно, либо значения не отсортировывались в нужном порядке + 3 коммита мелкие исправления\\ \hline
	15 21:33:11&cut last symbol&Заметил, что обрезается последний символ строки-значения (позже на место  строки в ключе записывалась вся строка ``ключ-значение'') + 18 коммитов на то, чтобы понять, что чекер дает очень большое количество строк на вход и нужно создать механизм динамического расширения выделенной памяти\\ \hline
	19 14:36:07&WORKING!!!!&Рабочая версия программы, чекер отправил ОК, далее была незначительная оптимизация кода и контроль кодстайла\\ \hline
\end{tabular}
\smallbreak


Так же при проверке работы программы учитывалось время её исполнения (утилита time), осуществлялся контроль различных ошибок и утечек памяти (утилита valgrind) и отдельно для тестов применялась утилита memusage.
%Что и когда делали, что не работало, как чинили. Этот пункт обязательный, если было сделано несколько посылок. Кратко опишите суть проблемы и способ ее устранения.

\subsection*{Тест производительности}
Тесты создавались с помощью небольшой программы на языке Python:
\begin{lstlisting}[language=python]
def tests():
    from random import randint as ri
    from os import urandom as ur
    res=[]
    for count in range(1,10):
        f=open(str(count)+'00k','w')
        for i in range(100000):
            res.append(str(ri(0,30))+'.'+\
            str(ri(0,12))+'.'+\
            str(ri(0,2020))+'\t'+\
            ur(ri(0,32)).hex())
        for i in res:
            f.write(i+'\n')
        f.close()

\end{lstlisting}
\begin{tabular}{|c |m{5cm}|}
	\hline
	Размер файла& Имя файла и количество тысяч строк в нём\\ \hline
	4,1M&	100k\\
	
	8,1M&	200k\\
	
	13M	&	300k\\
	
	17M	&	400k\\
	
	21M	&	500k\\
	
	25M	&	600k\\
	
	29M &	700k\\
	
	33M	&	800k\\
	
	37M	&	900k\\ \hline
\end{tabular}

\smallbreak

Результаты времени работы для указанных входных файлов:
\begin{enumerate}
	\item time ./lab01  <test/100k >/dev/null
	
	0,15s user 0,02s system 99\% cpu 0,169 total
	
	\item time ./lab01  <test/200k >/dev/null
	
	0,33s user 0,02s system 99\% cpu 0,352 total
	
	\item time ./lab01  <test/300k >/dev/null
	
	0,49s user 0,04s system 99\% cpu 0,528 total
	
	\item time ./lab01  <test/400k >/dev/null
	
	0,66s user 0,06s system 99\% cpu 0,723 total
	
	\item time ./lab01  <test/500k >/dev/null
	
	0,87s user 0,05s system 99\% cpu 0,926 total
	
	\item time ./lab01  <test/600k >/dev/null
	
	1,12s user 0,04s system 99\% cpu 1,165 total

	\item time ./lab01  <test/700k >/dev/null
	
	1,27s user 0,08s system 99\% cpu 1,354 total
	
	\item time ./lab01  <test/800k >/dev/null
	
	 1,52s user 0,08s system 99\% cpu 1,605 total
	
	\item time ./lab01  <test/900k >/dev/null
	
	1,74s user 0,11s system 99\% cpu 1,846 total
\end{enumerate}

\begin{tikzpicture}
\begin{axis}[ylabel=Время,xlabel=Количество строк]
\addplot coordinates {
	( 900, 1.846 )
	( 800, 1.605 )
	( 700, 1.354 )
	( 600, 1.165 )
	( 500, 0.926 )
	( 400, 0.723)
	( 300, 0.528)
	( 200, 0.352)
	( 100, 0.169)};
\end{axis}
\end{tikzpicture}

Итого: 

По графику результатов времени выполнения программы, её сложность близка к линейной.
\newpage

\begin{tikzpicture}
\begin{axis}[ylabel=Количество строк,xlabel=Килобайты]
\addplot coordinates {
	( 27995,  100 ) 
	( 60085,  200 )
	( 100989, 300 )
	( 150744, 400 )
	( 209406, 500 )
	( 276883, 600 )
	( 353210, 700 )
	( 438362, 800 )
	( 532384, 900 )};
\end{axis}
\end{tikzpicture}

Небольшой изгиб графика обусловлен тем, что при заполнении выделенной памяти выделяется дополнительная память для $100\ 000$ значений, а не для одного, что более логично, но менее эффективно.


%Померить время работы кода лабораторной и теста производительности на разных объемах входных данных. Сравнить результаты. Проверить, что рост времени работы при увеличении объема входных данных согласуется с заявленной сложностью.


\subsection*{Недочёты}

По необъяснимым и практически сверхъестественным причинам глобальная переменная \textit{TOTAL\_LINES}, объявленная в файле {\it main.cpp} при переносе в заголовочный файл вызывает ошибку ``multiple definition of `TOTAL\_LINES' ''

Описать те проблемы, которые остались нерешёнными в программе. Если
выявленных недочётов нет, то этот пункт можно пропустить. Если же
задача была принята с оговорками (медленно работает, неверно выполняет
какие-то тесты), то нужно обязательно их упомянуть, привести возможные
причины, указать почему не получилось исправить недочёты. 

\subsection*{Выводы}

Описать область применения реализованного алгоритма. Указать типовые
задачи, решаемые им. Оценить сложность программирования, кратко
описать возникшие проблемы при решении задачи. 

\end{document}

